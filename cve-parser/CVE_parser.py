class Vulnerability:
    """
    Class for representing necessary information about vulnerability.
    Dictionary is used for storing cvssv2 and cvssv3 because of constant access.
    cpe_type contains values:
        'h' for hardware,
        'a' for application,
        'o' for operating system.
    """

    def __init__(self):
        self.CVE_description_value = ""
        self.CVE_problem_type_value = ""
        self.cvssv2 = {}
        self.cvssv3 = {}
        self.cpe_type = set()


def read_lines_with_no_information(name_of_file):
    """
    Reads blocks with unnecessary information.
    :param name_of_file: The name of file from which function will read.
    Block ends with line containing only "},".
    """

    line = name_of_file.readline()
    while ('},' not in line)or('} , {' in line):
        line = name_of_file.readline()



def remove_quotation_marks(source_string):
    """
    :param source_string: String from which quotation marks will be removed (but only the outermost).
    :return: String without the outermost quotation marks and the outermost white characters.
    """
    first = source_string.find('"')
    second = source_string[first+1:].rfind('"')
    return source_string[first+1: second+first+1][:].strip()


def get_description_value(name_of_file):
    """
    :param name_of_file: Source file for function.
    :return: Description value for particular CVE.
    """
    line = name_of_file.readline()
    while 'value" :' not in line:
        line = name_of_file.readline()
    tmp_list = line.split(':')
    if len(tmp_list) == 2:
        value = tmp_list[1][:]
        return value
    else:
        # When description value contains ":" too.
        concatenation = ""
        for i in range(1, len(tmp_list)-1):
            concatenation = concatenation + tmp_list[i] + ":"
        concatenation = concatenation + tmp_list[-1]
        return concatenation


def get_problem_type_value(name_of_file):
    """
    :param name_of_file: Source file.
    :return: Problem type value describing weakness for particular CVE.
    """
    line = name_of_file.readline()
    while ('value" : ' not in line)and('},' not in line):
        line = name_of_file.readline()
    if '},' not in line:
        tmp_list = line.split(":")
        value = tmp_list[1][:]
        return value
    else:
        # Not every Problem type block contains value. Return value chosen for better further processing.
        return ""


def get_impact_vector_cvssv2(name_of_file):
    """
    :param name_of_file: Source file.
    :return: Dictionary containing cvssv2 information.
    """
    cvssv2_dict = {}
    line = name_of_file.readline()

    # Counting name of braces to know when we leave cvssv2 block.
    number_of_braces = 2

    while ('"av" :' not in line)and('"accessVector" :' not in line):
        line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv2_dict["av"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv2_dict["ac"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv2_dict["au"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv2_dict["c"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv2_dict["i"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv2_dict["a"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv2_dict["score"] = tmp_list[1].strip()

    while number_of_braces != 0:
        line = name_of_file.readline()
        if '}' in line:
            number_of_braces -= 1
        else:
            # We want to store also the other helpful information
            tmp_list = line.split(":")
            if len(tmp_list) == 2:
                cvssv2_dict[remove_quotation_marks(tmp_list[0])] = remove_quotation_marks(tmp_list[1]).rstrip(',')

    return cvssv2_dict


def get_impact_vector_cvssv3(name_of_file):
    """
    :param name_of_file: Source file.
    :return: Dictionary containing cvssv3 information.
    """
    cvssv3_dict = {}
    line = name_of_file.readline()

    # Counting name of braces to know when we leave cvssv2 block.
    number_of_braces = 2

    while ('"av" :' not in line)and('"attackVector" :' not in line):
        line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["av"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["ac"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["pr"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["ui"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["s"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["c"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["i"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["a"] = remove_quotation_marks(tmp_list[1])

    line = name_of_file.readline()
    tmp_list = line.split(":")
    cvssv3_dict["score"] = tmp_list[1].strip().rstrip(',')

    while number_of_braces != 0:
        line = name_of_file.readline()
        if '}' in line:
            number_of_braces -= 1
        else:
            tmp_list = line.split(":")
            if len(tmp_list) == 2:
                cvssv3_dict[remove_quotation_marks(tmp_list[0])] = remove_quotation_marks(tmp_list[1]).rstrip(',')

    return cvssv3_dict


def get_cpe_type(name_of_file):
    cpe_type = set()
    line = name_of_file.readline()

    while ('},' not in line)or('}, {' in line):
        if '"cpeMatchString" : "cpe:/' in line:
            cpe_type.add(line[line.find('"cpeMatchString" : "cpe:/') + len('"cpeMatchString" : "cpe:/')])
        line = name_of_file.readline()

    return cpe_type


def parse(name_of_file):
    """
    :param name_of_file: Source file.
    :return: Dictionary containing
    """
    dict_of_vulnerabilities = {}
    with open(name_of_file, "r") as cve_file:
        line = cve_file.readline()
        while line != "":
            if '"CVE_data_meta" : {' in line:
                # Store CVE_ID as key.
                line = cve_file.readline()
                tmp_list = line.split(':')
                cve_id = remove_quotation_marks(tmp_list[1])
                dict_of_vulnerabilities[cve_id] = Vulnerability()

                # The following line is "},"
                line = cve_file.readline()

                # The following block is block "affects".
                read_lines_with_no_information(cve_file)
                line = cve_file.readline()

                while line != "":
                    if '"description" : {' in line:
                        description_value = remove_quotation_marks(get_description_value(cve_file))
                        dict_of_vulnerabilities[cve_id].CVE_description_value = description_value
                        read_lines_with_no_information(cve_file)
                    elif '"impact" : {' in line:
                        if '"impact" : { },' in line:
                            # Impact block can be empty
                            break
                        line = cve_file.readline()
                        while "cvss" not in line:
                            line = cve_file.readline()
                        cvssv2_was_read = False

                        # cvssv2 and cvssv3 can be in both orders
                        if '2' in line:
                            cvssv2_vector = get_impact_vector_cvssv2(cve_file)
                            cvssv2_was_read = True
                            dict_of_vulnerabilities[cve_id].cvssv2 = cvssv2_vector
                            line = cve_file.readline()
                        if '3' in line:
                            cvssv3_vector = get_impact_vector_cvssv3(cve_file)
                            dict_of_vulnerabilities[cve_id].cvssv3 = cvssv3_vector

                            line = cve_file.readline()
                            line = cve_file.readline()

                            if not cvssv2_was_read:
                                cvssv2_vector = get_impact_vector_cvssv2(cve_file)
                                dict_of_vulnerabilities[cve_id].cvssv2 = cvssv2_vector

                        # Impact is the last block
                        break
                    elif '"problemtype" : {' in line:
                        problem_type_value = remove_quotation_marks(get_problem_type_value(cve_file))
                        dict_of_vulnerabilities[cve_id].CVE_problem_type_value = problem_type_value

                        if '},' not in line:
                            read_lines_with_no_information(cve_file)
                    elif '"configurations" : {' in line:
                        cpe_type = get_cpe_type(cve_file)
                        dict_of_vulnerabilities[cve_id].cpe_type = cpe_type
                    else:
                        read_lines_with_no_information(cve_file)

                    line = cve_file.readline()

            line = cve_file.readline()

    return dict_of_vulnerabilities
